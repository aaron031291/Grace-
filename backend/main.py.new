#!/usr/bin/env python3
"""
Grace Backend - Main FastAPI Application (Minimal Implementation)
"""

import asyncio
import logging
from contextlib import asynccontextmanager
from typing import AsyncGenerator

import uvicorn
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from starlette.datastructures import Headers
import hashlib

import time
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response
from collections import defaultdict, deque

from backend.config import get_settings
from backend.api.orb import router as orb_router


class RedactingFormatter(logging.Formatter):
    def __init__(self, fmt=None, datefmt=None, style="%"):
        super().__init__(fmt, datefmt, style)

    def format(self, record):
        msg = super().format(record)
        # Redact secrets
        try:
            settings = get_settings()
            secrets = [
                settings.jwt_secret_key,
                settings.secret_key,
                settings.storage_secret_key,
                settings.storage_access_key,
            ]
            for secret in secrets:
                if secret:
                    msg = msg.replace(secret, "[REDACTED]")
        except Exception:
            pass
        return msg


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
for handler in logging.getLogger().handlers:
    handler.setFormatter(RedactingFormatter(handler.formatter._fmt))

settings = get_settings()


# --- Idempotency Key Middleware ---
class IdempotencyMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, ttl_seconds: int = 300, max_size: int = 1000):
        super().__init__(app)
        self.cache = {}  # {hash_key: (body, status, headers, expires_at)}
        self.ttl_seconds = ttl_seconds
        self.max_size = max_size

    def _cleanup_expired(self):
        """Remove expired entries"""
        now = time.time()
        expired_keys = [k for k, v in self.cache.items() if v[3] < now]
        for k in expired_keys:
            del self.cache[k]

    async def dispatch(self, request: Request, call_next):
        if request.method in {"POST", "PUT", "PATCH", "DELETE"}:
            key = request.headers.get("Idempotency-Key")
            if not key:
                return JSONResponse(
                    status_code=400,
                    content={
                        "error": {
                            "code": "IDEMPOTENCY_KEY_REQUIRED",
                            "message": "Idempotency-Key header is required for mutating requests.",
                        }
                    },
                )
            
            # Cleanup expired entries periodically
            if len(self.cache) > self.max_size * 0.8:
                self._cleanup_expired()
            
            hash_key = hashlib.sha256(key.encode()).hexdigest()
            if hash_key in self.cache:
                cached = self.cache[hash_key]
                if cached[3] > time.time():  # Not expired
                    return JSONResponse(
                        content=cached[0],
                        status_code=cached[1],
                        headers=dict(cached[2])
                    )
                else:
                    del self.cache[hash_key]  # Remove expired
            
            response = await call_next(request)
            
            # Only cache successful responses
            if response.status_code < 400:
                # Read and cache response body
                body = b""
                async for chunk in response.body_iterator:
                    body += chunk
                
                import json
                try:
                    body_json = json.loads(body.decode())
                except:
                    body_json = body.decode()
                
                expires_at = time.time() + self.ttl_seconds
                
                # Enforce max size with LRU (remove oldest)
                if len(self.cache) >= self.max_size:
                    oldest_key = min(self.cache.keys(), key=lambda k: self.cache[k][3])
                    del self.cache[oldest_key]
                
                self.cache[hash_key] = (body_json, response.status_code, response.headers, expires_at)
                
                # Return new response with body
                return JSONResponse(
                    content=body_json,
                    status_code=response.status_code,
                    headers=dict(response.headers)
                )
            
            return response
        return await call_next(request)


# --- Rate Limiting Middleware ---
class TokenBucket:
    def __init__(self, rate: int, capacity: int):
        self.rate = rate  # tokens per second
        self.capacity = capacity
        self.tokens = capacity
        self.timestamp = time.time()

    def consume(self, tokens: int = 1) -> bool:
        now = time.time()
        elapsed = now - self.timestamp
        self.tokens = min(self.capacity, self.tokens + elapsed * self.rate)
        self.timestamp = now
        if self.tokens >= tokens:
            self.tokens -= tokens
            return True
        return False


class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, rate: int = 5, capacity: int = 10):
        super().__init__(app)
        self.rate = rate
        self.capacity = capacity
        self.buckets = defaultdict(lambda: TokenBucket(rate, capacity))

    async def dispatch(self, request: Request, call_next):
        ip = request.client.host
        bucket = self.buckets[ip]
        if not bucket.consume():
            return JSONResponse(
                status_code=429,
                content={
                    "error": {
                        "code": "RATE_LIMIT_EXCEEDED",
                        "message": "Too many requests. Please try again later.",
                    }
                },
            )
        response = await call_next(request)
        return response


# --- Pydantic Schemas ---
class HealthCheckResponse(BaseModel):
    status: str
    version: str
    service: str


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """Application lifespan management."""
    logger.info("ðŸš€ Starting Grace Backend...")
    
    # Initialize ALL Grace kernels
    try:
        import sys
        from pathlib import Path
        
        # Add parent directory to path
        parent_dir = Path(__file__).parent.parent
        if str(parent_dir) not in sys.path:
            sys.path.insert(0, str(parent_dir))
        
        from grace.core.kernel_manager import get_kernel_manager
        
        kernel_manager = get_kernel_manager()
        await kernel_manager.initialize_all_kernels()
        
        app.state.kernel_manager = kernel_manager
        
        status = kernel_manager.get_all_status()
        logger.info(f"âœ… Kernels: {status['operational_kernels']}/{status['total_kernels']} operational")
        
    except Exception as e:
        logger.warning(f"âš ï¸  Kernel initialization failed: {e}")
        logger.warning("   Backend will work with basic features")
    
    # Initialize Grace autonomous system (uses kernels)
    try:
        from backend.grace_integration import initialize_grace_for_backend
        grace = await initialize_grace_for_backend(app)
        
        if grace:
            logger.info("âœ… Grace autonomous system integrated")
        else:
            logger.info("âš ï¸  Grace running in basic mode")
    except Exception as e:
        logger.warning(f"âš ï¸  Grace autonomous integration: {e}")
    
    logger.info("âœ… Grace Backend startup complete")

    yield

    logger.info("ðŸ”„ Shutting down Grace Backend...")
    logger.info("âœ… Grace Backend shutdown complete")


def create_app() -> FastAPI:
    from starlette.middleware.base import BaseHTTPMiddleware

    class SecurityHeadersMiddleware(BaseHTTPMiddleware):
        async def dispatch(self, request, call_next):
            response = await call_next(request)
            response.headers["Content-Security-Policy"] = (
                "default-src 'self'; script-src 'self'; object-src 'none';"
            )
            response.headers["Strict-Transport-Security"] = (
                "max-age=63072000; includeSubDomains; preload"
            )
            response.headers["Referrer-Policy"] = "no-referrer-when-downgrade"
            return response

    app = FastAPI(
        title="Grace Backend",
        description="Comprehensive AI governance system backend",
        version="1.0.0",
        docs_url="/api/docs" if settings.debug else None,
        redoc_url="/api/redoc" if settings.debug else None,
        lifespan=lifespan,
    )

    app.add_middleware(SecurityHeadersMiddleware)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.cors_origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    app.add_middleware(RateLimitMiddleware, rate=5, capacity=10)
    app.add_middleware(IdempotencyMiddleware)

    # Wire OpenTelemetry tracing
    try:
        from backend.observability.tracing import init_tracing

        init_tracing(app)
    except Exception as e:
        logger.warning(f"OpenTelemetry tracing not initialized: {e}")

    # Include API routers
    from backend.api.auth import router as auth_router
    from backend.api.health import router as health_router
    from backend.api.memory import router as memory_router
    from backend.api.tasks import router as tasks_router
    from backend.api.governance import router as governance_router
    from backend.api.websocket import router as websocket_router
    
    app.include_router(orb_router, prefix="/api/orb", tags=["orb"])
    app.include_router(auth_router, prefix="/api/auth", tags=["auth"])
    app.include_router(health_router, prefix="/api/health", tags=["health"])
    app.include_router(memory_router, prefix="/api/memory", tags=["memory"])
    app.include_router(tasks_router, prefix="/api/tasks", tags=["tasks"])
    app.include_router(governance_router, prefix="/api/governance", tags=["governance"])
    app.include_router(websocket_router, prefix="/api/ws", tags=["websocket"])

    from backend.auth import create_access_token, create_refresh_token, verify_token
    from pydantic import BaseModel

    class TokenRequest(BaseModel):
        username: str
        password: str

    class TokenResponse(BaseModel):
        access_token: str
        refresh_token: str
        token_type: str = "bearer"

    class RefreshRequest(BaseModel):
        refresh_token: str

    @app.post("/api/auth/token", response_model=TokenResponse)
    async def login(request: TokenRequest):
        # Temporary admin login (only in debug mode)
        if settings.debug and request.username == "admin" and request.password == "admin":
            logger.warning("âš ï¸  Using hardcoded admin credentials (DEBUG MODE ONLY)")
            access_token = create_access_token(
                {"sub": request.username, "role": "admin"}
            )
            refresh_token = create_refresh_token(
                {"sub": request.username, "role": "admin"}
            )
            return TokenResponse(access_token=access_token, refresh_token=refresh_token)
        return JSONResponse(
            status_code=401,
            content={
                "error": {
                    "code": "INVALID_CREDENTIALS",
                    "message": "Invalid username or password.",
                }
            },
        )

    @app.post("/api/auth/refresh", response_model=TokenResponse)
    async def refresh_token(request: RefreshRequest):
        try:
            payload = verify_token(request.refresh_token)
            if payload.get("type") != "refresh":
                raise Exception("Not a refresh token")
            access_token = create_access_token(
                {"sub": payload["sub"], "role": payload["role"]}
            )
            refresh_token = create_refresh_token(
                {"sub": payload["sub"], "role": payload["role"]}
            )
            return TokenResponse(access_token=access_token, refresh_token=refresh_token)
        except Exception:
            return JSONResponse(
                status_code=401,
                content={
                    "error": {
                        "code": "INVALID_REFRESH_TOKEN",
                        "message": "Invalid or expired refresh token.",
                    }
                },
            )

    from .middleware.auth import get_current_user

    @app.get("/api/auth/me")
    async def get_current_user_info(current_user: dict = Depends(get_current_user)):
        """Get current authenticated user information"""
        return {
            "id": current_user.get("sub"),
            "username": current_user.get("sub"),
            "email": f"{current_user.get('sub')}@example.com",
            "full_name": current_user.get("sub"),
            "is_active": True,
            "is_superuser": current_user.get("role") == "admin"
        }

    @app.get("/api/health", response_model=HealthCheckResponse)
    async def health_check() -> HealthCheckResponse:
        return HealthCheckResponse(
            status="healthy", version="1.0.0", service="grace-backend"
        )

    @app.get("/api/metrics")
    async def get_app_metrics():
        """Get application metrics"""
        from .middleware.metrics import get_metrics
        return get_metrics()

    import uuid

    @app.exception_handler(Exception)
    async def global_exception_handler(request: Request, exc: Exception):
        logger.error(f"Unhandled exception: {exc}", exc_info=True)
        trace_id = str(uuid.uuid4())
        return JSONResponse(
            status_code=500,
            content={
                "error": {
                    "code": "INTERNAL_ERROR",
                    "message": "An internal error occurred",
                    "trace_id": trace_id,
                    "detail": str(exc) if settings.debug else None,
                }
            },
        )

    return app


app = create_app()


if __name__ == "__main__":
    uvicorn.run(
        "backend.main:app",
        host="0.0.0.0",
        port=8000,
        reload=settings.debug,
        log_level="info",
    )
