"""
ml_contracts.py
Grace ML Contracts â€” strict Pydantic v2 models mirroring:
https://grace.ai/schemas/ml-contracts/v1

- Strong pattern checks for UID / SemVer / Sha256
- UTC-safe datetimes
- Typed AdaptationPlan actions (hpo, reweight_specialists, policy_delta, canary)
- Light normalization for string lists
"""

from __future__ import annotations

from datetime import datetime, timezone
from typing import Any, Dict, List, Mapping, Optional, Union, Literal
from pydantic import BaseModel, Field, field_validator


# ---------------------------
# Helpers / Base
# ---------------------------

def _utcnow() -> datetime:
    return datetime.now(timezone.utc)

class StrictModel(BaseModel):
    model_config = {
        "extra": "forbid",
        "validate_assignment": True,
        "use_enum_values": True,
        "ser_json_bytes": "utf8",
        "populate_by_name": True,
    }


# ---------------------------
# $defs
# ---------------------------

class SemVer(StrictModel):
    value: str = Field(pattern=r"^[0-9]+\.[0-9]+\.[0-9]+$")

    def __str__(self) -> str:  # nice repr
        return self.value

class UID(StrictModel):
    value: str = Field(pattern=r"^[a-z][a-z0-9_-]{4,64}$")
    def __str__(self) -> str:
        return self.value

class ISO8601(StrictModel):
    value: datetime

    @field_validator("value", mode="before")
    @classmethod
    def _tz(cls, v: Any) -> datetime:
        if isinstance(v, datetime):
            return v if v.tzinfo else v.replace(tzinfo=timezone.utc)
        dt = datetime.fromisoformat(str(v).replace("Z", "+00:00"))
        return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)

class Sha256(StrictModel):
    value: str = Field(pattern=r"^sha256:[a-f0-9]{64}$")
    def __str__(self) -> str:
        return self.value


# ---------------------------
# Enums (as Literals for parity)
# ---------------------------

Task = Literal["classification", "regression", "clustering", "dimred", "rl"]

InsightType = Literal[
    "performance", "drift", "fairness", "calibration", "stability", "governance_alignment"
]

InsightScope = Literal["model", "specialist", "policy", "dataset", "segment"]


# ---------------------------
# SpecialistReport
# ---------------------------

class Candidate(StrictModel):
    model_key: str
    version: SemVer
    artifact_uri: str
    metrics: Mapping[str, Any]
    risks: Optional[List[str]] = None
    explanations: Optional[Mapping[str, Any]] = None
    validation_hash: Optional[Sha256] = None

    @field_validator("risks", mode="after")
    @classmethod
    def _norm_risks(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        if v is None:
            return None
        seen, out = set(), []
        for x in v:
            if isinstance(x, str):
                s = x.strip()
                if s and s not in seen:
                    seen.add(s)
                    out.append(s)
        return out

class SpecialistReport(StrictModel):
    report_id: UID
    specialist: str  # e.g., "Tabular-Classification"
    task: Task
    candidates: List[Candidate]
    dataset_id: Optional[str] = None
    notes: Optional[str] = None
    timestamp: ISO8601
    version: SemVer


# ---------------------------
# Experience
# ---------------------------

class ExperienceContext(StrictModel):
    dataset_id: Optional[str] = None
    model_key: Optional[str] = None
    model_version: Optional[SemVer] = None
    segment: Optional[str] = None
    env: Optional[Literal["dev", "staging", "prod"]] = None

class ExperienceSignalsDrift(StrictModel):
    psi: Optional[float] = None
    kl: Optional[float] = None
    mmd: Optional[float] = None

class ExperienceSignalsFairness(StrictModel):
    delta: Optional[float] = None
    groups: Optional[List[str]] = None

    @field_validator("groups", mode="after")
    @classmethod
    def _norm_groups(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        if v is None:
            return None
        seen, out = set(), []
        for x in v:
            if isinstance(x, str):
                s = x.strip()
                if s and s not in seen:
                    seen.add(s)
                    out.append(s)
        return out

class ExperienceSignalsLatency(StrictModel):
    p95_ms: Optional[float] = None

class ExperienceSignalsCompliance(StrictModel):
    constitutional: Optional[float] = None

class ExperienceSignals(StrictModel):
    metrics: Optional[Mapping[str, Any]] = None
    drift: Optional[ExperienceSignalsDrift] = None
    fairness: Optional[ExperienceSignalsFairness] = None
    latency: Optional[ExperienceSignalsLatency] = None
    compliance: Optional[ExperienceSignalsCompliance] = None

class Experience(StrictModel):
    experience_id: UID
    source: Literal["training", "inference", "governance", "ops"]
    task: Task
    context: ExperienceContext
    signals: ExperienceSignals
    ground_truth_lag_s: Optional[int] = Field(default=None, ge=0)
    timestamp: ISO8601


# ---------------------------
# Insight
# ---------------------------

class Insight(StrictModel):
    insight_id: UID
    type: InsightType
    scope: InsightScope
    target_ref: Optional[str] = Field(default=None, description="e.g., model_key or policy path")
    evidence: Mapping[str, Any]
    confidence: float = Field(ge=0.0, le=1.0)
    recommendation: Optional[
        Literal["retrain", "reweight", "recalibrate", "hpo", "policy_tune", "segment_route"]
    ] = None
    timestamp: ISO8601


# ---------------------------
# AdaptationPlan (+ action variants)
# ---------------------------

class HPOBudget(StrictModel):
    trials: Optional[int] = None
    max_runtime_min: Optional[int] = None

class ActionHPO(StrictModel):
    type: Literal["hpo"] = "hpo"
    target: str  # family or model_key
    budget: HPOBudget
    success_metric: str

class ActionReweight(StrictModel):
    type: Literal["reweight_specialists"] = "reweight_specialists"
    weights: Mapping[str, float]  # e.g., {"Fairness": 1.05}

class ActionPolicyDelta(StrictModel):
    type: Literal["policy_delta"] = "policy_delta"
    path: str  # e.g., governance.thresholds.min_calibration
    **_from_to: Mapping[str, Any]  # to avoid Python keywords; implemented with validators

    # use explicit fields to keep dump clean
    from_: Any = Field(alias="from")
    to: Any

    model_config = {"populate_by_name": True, "extra": "forbid"}

class ActionCanary(StrictModel):
    type: Literal["canary"] = "canary"
    target_model: str
    steps: List[int]

AdaptationAction = Union[ActionHPO, ActionReweight, ActionPolicyDelta, ActionCanary]

class AdaptationPlan(StrictModel):
    plan_id: UID
    actions: List[AdaptationAction] = Field(min_length=1)
    expected_effect: Mapping[str, Any]
    risk_controls: Mapping[str, Any]  # {"max_regret_pct": ..., "halt_on_drift_z": ...}
    created_at: ISO8601
    version: SemVer


# ---------------------------
# Snapshots
# ---------------------------

class GovernanceSnapshot(StrictModel):
    snapshot_id: UID
    instance_id: UID
    version: SemVer
    policies: Mapping[str, Any]
    thresholds: Mapping[str, Any]
    model_weights: Mapping[str, Any]
    state_hash: Sha256
    created_at: ISO8601

class MLTSnapshot(StrictModel):
    snapshot_id: UID
    planner_version: SemVer
    search_spaces: Mapping[str, Any]
    weights: Mapping[str, Any]
    policies: Mapping[str, Any]
    active_jobs: List[Any]
    hash: Sha256


__all__ = [
    # defs
    "SemVer", "UID", "ISO8601", "Sha256",
    # enums
    "Task", "InsightType", "InsightScope",
    # reports
    "Candidate", "SpecialistReport",
    # experience
    "ExperienceContext", "ExperienceSignalsDrift", "ExperienceSignalsFairness",
    "ExperienceSignalsLatency", "ExperienceSignalsCompliance", "ExperienceSignals",
    "Experience",
    # insight
    "Insight",
    # plans
    "HPOBudget", "ActionHPO", "ActionReweight", "ActionPolicyDelta", "ActionCanary",
    "AdaptationAction", "AdaptationPlan",
    # snapshots
    "GovernanceSnapshot", "MLTSnapshot",
]
